{"ast":null,"code":"import { __values } from \"tslib\";\nimport { KEY_TYPE_IDENTIFIER, MAX_CACHE_SIZE } from \"./constants\";\nvar signingKeyCache = {};\nvar cacheQueue = [];\n/**\n * Create a string describing the scope of credentials used to sign a request.\n *\n * @param shortDate The current calendar date in the form YYYYMMDD.\n * @param region    The AWS region in which the service resides.\n * @param service   The service to which the signed request is being sent.\n */\n\nexport function createScope(shortDate, region, service) {\n  return shortDate + \"/\" + region + \"/\" + service + \"/\" + KEY_TYPE_IDENTIFIER;\n}\n/**\n * Derive a signing key from its composite parts\n *\n * @param sha256Constructor A constructor function that can instantiate SHA-256\n *                          hash objects.\n * @param credentials       The credentials with which the request will be\n *                          signed.\n * @param shortDate         The current calendar date in the form YYYYMMDD.\n * @param region            The AWS region in which the service resides.\n * @param service           The service to which the signed request is being\n *                          sent.\n */\n\nexport function getSigningKey(sha256Constructor, credentials, shortDate, region, service) {\n  var cacheKey = shortDate + \":\" + region + \":\" + service + \":\" + (credentials.accessKeyId + \":\" + credentials.sessionToken);\n\n  if (cacheKey in signingKeyCache) {\n    return signingKeyCache[cacheKey];\n  }\n\n  cacheQueue.push(cacheKey);\n\n  while (cacheQueue.length > MAX_CACHE_SIZE) {\n    delete signingKeyCache[cacheQueue.shift()];\n  }\n\n  return signingKeyCache[cacheKey] = new Promise(function (resolve, reject) {\n    var e_1, _a;\n\n    var keyPromise = Promise.resolve(\"AWS4\" + credentials.secretAccessKey);\n\n    var _loop_1 = function (signable) {\n      keyPromise = keyPromise.then(function (intermediateKey) {\n        return hmac(sha256Constructor, intermediateKey, signable);\n      });\n      keyPromise.catch(function () {});\n    };\n\n    try {\n      for (var _b = __values([shortDate, region, service, KEY_TYPE_IDENTIFIER]), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var signable = _c.value;\n\n        _loop_1(signable);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    keyPromise.then(resolve, function (reason) {\n      delete signingKeyCache[cacheKey];\n      reject(reason);\n    });\n  });\n}\n/**\n * @internal\n */\n\nexport function clearCredentialCache() {\n  cacheQueue.length = 0;\n  Object.keys(signingKeyCache).forEach(function (cacheKey) {\n    delete signingKeyCache[cacheKey];\n  });\n}\n\nfunction hmac(ctor, secret, data) {\n  var hash = new ctor(secret);\n  hash.update(data);\n  return hash.digest();\n}","map":{"version":3,"sources":["../../src/credentialDerivation.ts"],"names":[],"mappings":";AAEA,SAAS,mBAAT,EAA8B,cAA9B,QAAoD,aAApD;AAEA,IAAM,eAAe,GAA2C,EAAhE;AACA,IAAM,UAAU,GAAkB,EAAlC;AAEA;;;;;;;;AAOA,OAAM,SAAU,WAAV,CAAsB,SAAtB,EAAyC,MAAzC,EAAyD,OAAzD,EAAwE;AAC5E,SAAU,SAAS,GAAA,GAAT,GAAa,MAAb,GAAmB,GAAnB,GAAuB,OAAvB,GAA8B,GAA9B,GAAkC,mBAA5C;AACD;AAED;;;;;;;;;;;;;AAYA,OAAM,SAAU,aAAV,CACJ,iBADI,EAEJ,WAFI,EAGJ,SAHI,EAIJ,MAJI,EAKJ,OALI,EAKW;AAEf,MAAM,QAAQ,GAAM,SAAS,GAAA,GAAT,GAAa,MAAb,GAAmB,GAAnB,GAAuB,OAAvB,GAA8B,GAA9B,IAAuC,WAAW,CAAC,WAAZ,GAAuB,GAAvB,GAA2B,WAAW,CAAC,YAA9E,CAApB;;AACA,MAAI,QAAQ,IAAI,eAAhB,EAAiC;AAC/B,WAAO,eAAe,CAAC,QAAD,CAAtB;AACD;;AAED,EAAA,UAAU,CAAC,IAAX,CAAgB,QAAhB;;AACA,SAAO,UAAU,CAAC,MAAX,GAAoB,cAA3B,EAA2C;AACzC,WAAO,eAAe,CAAC,UAAU,CAAC,KAAX,EAAD,CAAtB;AACD;;AAED,SAAQ,eAAe,CAAC,QAAD,CAAf,GAA4B,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;;;AAC9D,QAAI,UAAU,GAAwB,OAAO,CAAC,OAAR,CAAgB,SAAO,WAAW,CAAC,eAAnC,CAAtC;;4BAEW,Q,EAAQ;AACjB,MAAA,UAAU,GAAG,UAAU,CAAC,IAAX,CAA4B,UAAC,eAAD,EAAgB;AAAK,eAAA,IAAI,CAAC,iBAAD,EAAoB,eAApB,EAAJ,QAAI,CAAJ;AAAkD,OAAnG,CAAb;AACA,MAAA,UAAU,CAAC,KAAX,CAAiB,YAAA,CAAQ,CAAzB;;;;AAFF,WAAuB,IAAA,EAAA,GAAA,QAAA,CAAA,CAAC,SAAD,EAAY,MAAZ,EAAoB,OAApB,EAA6B,mBAA7B,CAAA,CAAA,EAAiD,EAAA,GAAA,EAAA,CAAA,IAAA,EAAxE,EAAwE,CAAA,EAAA,CAAA,IAAxE,EAAwE,EAAA,GAAA,EAAA,CAAA,IAAA,EAAxE,EAAwE;AAAnE,YAAM,QAAQ,GAAA,EAAA,CAAA,KAAd;;gBAAM,Q;AAGV;;;;;;;;;;;;;AAEA,IAAA,UAAkC,CAAC,IAAnC,CAAwC,OAAxC,EAAiD,UAAC,MAAD,EAAO;AACvD,aAAO,eAAe,CAAC,QAAD,CAAtB;AACA,MAAA,MAAM,CAAC,MAAD,CAAN;AACD,KAHA;AAIF,GAZmC,CAApC;AAaD;AAED;;;;AAGA,OAAM,SAAU,oBAAV,GAA8B;AAClC,EAAA,UAAU,CAAC,MAAX,GAAoB,CAApB;AACA,EAAA,MAAM,CAAC,IAAP,CAAY,eAAZ,EAA6B,OAA7B,CAAqC,UAAC,QAAD,EAAS;AAC5C,WAAO,eAAe,CAAC,QAAD,CAAtB;AACD,GAFD;AAGD;;AAED,SAAS,IAAT,CAAc,IAAd,EAAqC,MAArC,EAAyD,IAAzD,EAAyE;AACvE,MAAM,IAAI,GAAG,IAAI,IAAJ,CAAS,MAAT,CAAb;AACA,EAAA,IAAI,CAAC,MAAL,CAAY,IAAZ;AACA,SAAO,IAAI,CAAC,MAAL,EAAP;AACD","sourceRoot":"","sourcesContent":["import { __values } from \"tslib\";\nimport { KEY_TYPE_IDENTIFIER, MAX_CACHE_SIZE } from \"./constants\";\nvar signingKeyCache = {};\nvar cacheQueue = [];\n/**\n * Create a string describing the scope of credentials used to sign a request.\n *\n * @param shortDate The current calendar date in the form YYYYMMDD.\n * @param region    The AWS region in which the service resides.\n * @param service   The service to which the signed request is being sent.\n */\nexport function createScope(shortDate, region, service) {\n    return shortDate + \"/\" + region + \"/\" + service + \"/\" + KEY_TYPE_IDENTIFIER;\n}\n/**\n * Derive a signing key from its composite parts\n *\n * @param sha256Constructor A constructor function that can instantiate SHA-256\n *                          hash objects.\n * @param credentials       The credentials with which the request will be\n *                          signed.\n * @param shortDate         The current calendar date in the form YYYYMMDD.\n * @param region            The AWS region in which the service resides.\n * @param service           The service to which the signed request is being\n *                          sent.\n */\nexport function getSigningKey(sha256Constructor, credentials, shortDate, region, service) {\n    var cacheKey = shortDate + \":\" + region + \":\" + service + \":\" + (credentials.accessKeyId + \":\" + credentials.sessionToken);\n    if (cacheKey in signingKeyCache) {\n        return signingKeyCache[cacheKey];\n    }\n    cacheQueue.push(cacheKey);\n    while (cacheQueue.length > MAX_CACHE_SIZE) {\n        delete signingKeyCache[cacheQueue.shift()];\n    }\n    return (signingKeyCache[cacheKey] = new Promise(function (resolve, reject) {\n        var e_1, _a;\n        var keyPromise = Promise.resolve(\"AWS4\" + credentials.secretAccessKey);\n        var _loop_1 = function (signable) {\n            keyPromise = keyPromise.then(function (intermediateKey) { return hmac(sha256Constructor, intermediateKey, signable); });\n            keyPromise.catch(function () { });\n        };\n        try {\n            for (var _b = __values([shortDate, region, service, KEY_TYPE_IDENTIFIER]), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var signable = _c.value;\n                _loop_1(signable);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        keyPromise.then(resolve, function (reason) {\n            delete signingKeyCache[cacheKey];\n            reject(reason);\n        });\n    }));\n}\n/**\n * @internal\n */\nexport function clearCredentialCache() {\n    cacheQueue.length = 0;\n    Object.keys(signingKeyCache).forEach(function (cacheKey) {\n        delete signingKeyCache[cacheKey];\n    });\n}\nfunction hmac(ctor, secret, data) {\n    var hash = new ctor(secret);\n    hash.update(data);\n    return hash.digest();\n}\n//# sourceMappingURL=credentialDerivation.js.map"]},"metadata":{},"sourceType":"module"}