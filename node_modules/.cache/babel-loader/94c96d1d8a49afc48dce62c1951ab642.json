{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveRetryConfig = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar defaultStrategy_1 = require(\"./defaultStrategy\");\n\nexports.resolveRetryConfig = function (input) {\n  var _a;\n\n  var maxAttempts = (_a = normalizeMaxAttempts(input.maxAttempts)) !== null && _a !== void 0 ? _a : input.maxAttemptsDefaultProvider(input);\n  return tslib_1.__assign(tslib_1.__assign({}, input), {\n    maxAttempts: maxAttempts,\n    retryStrategy: input.retryStrategy || new defaultStrategy_1.StandardRetryStrategy(maxAttempts)\n  });\n};\n\nvar normalizeMaxAttempts = function (maxAttempts) {\n  if (maxAttempts) {\n    var promisified_1 = Promise.resolve(maxAttempts.toString());\n    return function () {\n      return promisified_1;\n    };\n  }\n};","map":{"version":3,"sources":["../../src/configurations.ts"],"names":[],"mappings":";;;;;;;;;AAEA,IAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAqBa,OAAA,CAAA,kBAAA,GAAqB,UAAI,KAAJ,EAAoD;;;AACpF,MAAM,WAAW,GAAA,CAAA,EAAA,GAAG,oBAAoB,CAAC,KAAK,CAAC,WAAP,CAAvB,MAA0C,IAA1C,IAA0C,EAAA,KAAA,KAAA,CAA1C,GAA0C,EAA1C,GAA8C,KAAK,CAAC,0BAAN,CAAiC,KAAjC,CAA/D;AACA,SAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACK,KADL,CAAA,EACU;AACR,IAAA,WAAW,EAAA,WADH;AAER,IAAA,aAAa,EAAE,KAAK,CAAC,aAAN,IAAuB,IAAI,iBAAA,CAAA,qBAAJ,CAA0B,WAA1B;AAF9B,GADV,CAAA;AAKD,CAPY;;AASb,IAAM,oBAAoB,GAAG,UAAC,WAAD,EAAqB;AAChD,MAAI,WAAJ,EAAiB;AACf,QAAM,aAAW,GAAG,OAAO,CAAC,OAAR,CAAgB,WAAW,CAAC,QAAZ,EAAhB,CAApB;AACA,WAAO,YAAA;AAAM,aAAA,aAAA;AAAW,KAAxB;AACD;AACF,CALD","sourcesContent":["import { Provider, RetryStrategy } from \"@aws-sdk/types\";\n\nimport { StandardRetryStrategy } from \"./defaultStrategy\";\n\nexport interface RetryInputConfig {\n  /**\n   * The maximum number of times requests that encounter retryable failures should be attempted.\n   */\n  maxAttempts?: number;\n  /**\n   * The strategy to retry the request. Using built-in exponential backoff strategy by default.\n   */\n  retryStrategy?: RetryStrategy;\n}\n\ninterface PreviouslyResolved {\n  maxAttemptsDefaultProvider: (input: any) => Provider<string>;\n}\nexport interface RetryResolvedConfig {\n  maxAttempts: Provider<string>;\n  retryStrategy: RetryStrategy;\n}\n\nexport const resolveRetryConfig = <T>(input: T & PreviouslyResolved & RetryInputConfig): T & RetryResolvedConfig => {\n  const maxAttempts = normalizeMaxAttempts(input.maxAttempts) ?? input.maxAttemptsDefaultProvider(input as any);\n  return {\n    ...input,\n    maxAttempts,\n    retryStrategy: input.retryStrategy || new StandardRetryStrategy(maxAttempts),\n  };\n};\n\nconst normalizeMaxAttempts = (maxAttempts?: number): Provider<string> | undefined => {\n  if (maxAttempts) {\n    const promisified = Promise.resolve(maxAttempts.toString());\n    return () => promisified;\n  }\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}