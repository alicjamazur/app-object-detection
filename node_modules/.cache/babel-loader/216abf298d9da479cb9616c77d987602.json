{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAwsAuthPlugin = exports.awsAuthMiddlewareOptions = exports.awsAuthMiddleware = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar protocol_http_1 = require(\"@aws-sdk/protocol-http\");\n\nvar isClockSkewed = function (newServerTime, systemClockOffset) {\n  return Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - newServerTime) >= 300000;\n};\n\nvar getSkewCorrectedDate = function (systemClockOffset) {\n  return new Date(Date.now() + systemClockOffset);\n};\n\nfunction awsAuthMiddleware(options) {\n  return function (next) {\n    return function (args) {\n      return tslib_1.__awaiter(this, void 0, void 0, function () {\n        var signer, _a, output, _b, _c, _d, headers, dateHeader, serverTime;\n\n        return tslib_1.__generator(this, function (_e) {\n          switch (_e.label) {\n            case 0:\n              if (!protocol_http_1.HttpRequest.isInstance(args.request)) return [2\n              /*return*/\n              , next(args)];\n              if (!(typeof options.signer === \"function\")) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , options.signer()];\n\n            case 1:\n              _a = _e.sent();\n              return [3\n              /*break*/\n              , 3];\n\n            case 2:\n              _a = options.signer;\n              _e.label = 3;\n\n            case 3:\n              signer = _a;\n              _b = next;\n              _c = [tslib_1.__assign({}, args)];\n              _d = {};\n              return [4\n              /*yield*/\n              , signer.sign(args.request, {\n                signingDate: new Date(Date.now() + options.systemClockOffset)\n              })];\n\n            case 4:\n              return [4\n              /*yield*/\n              , _b.apply(void 0, [tslib_1.__assign.apply(void 0, _c.concat([(_d.request = _e.sent(), _d)]))])];\n\n            case 5:\n              output = _e.sent();\n              headers = output.response.headers;\n              dateHeader = headers && (headers.date || headers.Date);\n\n              if (dateHeader) {\n                serverTime = Date.parse(dateHeader);\n\n                if (isClockSkewed(serverTime, options.systemClockOffset)) {\n                  options.systemClockOffset = serverTime - Date.now();\n                }\n              }\n\n              return [2\n              /*return*/\n              , output];\n          }\n        });\n      });\n    };\n  };\n}\n\nexports.awsAuthMiddleware = awsAuthMiddleware;\nexports.awsAuthMiddlewareOptions = {\n  name: \"awsAuthMiddleware\",\n  step: \"finalizeRequest\",\n  tags: [\"SIGNATURE\", \"AWSAUTH\"],\n  relation: \"after\",\n  toMiddleware: \"retryMiddleware\"\n};\n\nexports.getAwsAuthPlugin = function (options) {\n  return {\n    applyToStack: function (clientStack) {\n      clientStack.addRelativeTo(awsAuthMiddleware(options), exports.awsAuthMiddlewareOptions);\n    }\n  };\n};","map":{"version":3,"sources":["../../src/middleware.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpRequest } from \"@aws-sdk/protocol-http\";\nimport {\n  FinalizeHandler,\n  FinalizeHandlerArguments,\n  FinalizeHandlerOutput,\n  FinalizeRequestHandlerOptions,\n  FinalizeRequestMiddleware,\n  Pluggable,\n  RelativeLocation,\n} from \"@aws-sdk/types\";\n\nimport { AwsAuthResolvedConfig } from \"./configurations\";\n\nconst isClockSkewed = (newServerTime: number, systemClockOffset: number) =>\n  Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - newServerTime) >= 300000;\n\nconst getSkewCorrectedDate = (systemClockOffset: number) => new Date(Date.now() + systemClockOffset);\n\nexport function awsAuthMiddleware<Input extends object, Output extends object>(\n  options: AwsAuthResolvedConfig\n): FinalizeRequestMiddleware<Input, Output> {\n  return (next: FinalizeHandler<Input, Output>): FinalizeHandler<Input, Output> =>\n    async function (args: FinalizeHandlerArguments<Input>): Promise<FinalizeHandlerOutput<Output>> {\n      if (!HttpRequest.isInstance(args.request)) return next(args);\n      const signer = typeof options.signer === \"function\" ? await options.signer() : options.signer;\n      const output = await next({\n        ...args,\n        request: await signer.sign(args.request, {\n          signingDate: new Date(Date.now() + options.systemClockOffset),\n        }),\n      });\n\n      const { headers } = output.response as any;\n      const dateHeader = headers && (headers.date || headers.Date);\n      if (dateHeader) {\n        const serverTime = Date.parse(dateHeader);\n        if (isClockSkewed(serverTime, options.systemClockOffset)) {\n          options.systemClockOffset = serverTime - Date.now();\n        }\n      }\n\n      return output;\n    };\n}\n\nexport const awsAuthMiddlewareOptions: FinalizeRequestHandlerOptions & RelativeLocation<any, any> = {\n  name: \"awsAuthMiddleware\",\n  step: \"finalizeRequest\",\n  tags: [\"SIGNATURE\", \"AWSAUTH\"],\n  relation: \"after\",\n  toMiddleware: \"retryMiddleware\",\n};\n\nexport const getAwsAuthPlugin = (options: AwsAuthResolvedConfig): Pluggable<any, any> => ({\n  applyToStack: (clientStack) => {\n    clientStack.addRelativeTo(awsAuthMiddleware(options), awsAuthMiddlewareOptions);\n  },\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}